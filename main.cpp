#include <iostream>
#include <vector>

template <class T>
        // Своя реализация  функции swap.
void Swap(T& first, T& second){
    T* temp = new T;
    *temp = first;
    first = second;
    second = *temp;
    delete temp;
};

// Функция восстановления свойств кучи, ставит корневой элемент на соответствующее место в куче.
template <class T>
//Принимае шаблонный массив, его размер и индекс текущего элемента.
void Heapify(T array[], int size, int current = 0){
    int largest = current; // Объявляем переменную для индекса наибольшего элемента, по умолчанию это корневой элемент.
    int left = 2*current +1; // Объявляем левого и правого потомков
    int right = 2*current +2;
    // Проверка на наибольшее число в поддереве.
    if (left < size && array[left] > array[largest]){ // Так как мы можем рекурсивно зайти в элемент без потомков, устонавливаем в условии
        largest = left;//- что индекс левого и правого потомка, не выходят за рамки массива.
    }
    if (right < size && array[right] > array[largest]){
        largest = right;
    }
    // Если индекс наибольшего элемента, не соответствует корневому то меняем их местами.
    if (largest != current){
        Swap(array[largest], array[current]);
        // Так как после замены, предыдущий корневой элемент может стать корневым элементом для дерева уровнем ниже, необходимо проверить
        // Будет ли это дерево соответствовать свойству кучи.
        // Для этого вызываем функцию рекурсивно указывая индекс по которому лежал наибольший элемент в качестве текущего(корневого) для дерева уровнем ниже.
        // Когда рекурсия дойдёт до дерева без потомков, условия которые могли бы изменить значение наибольшего элемена не выполняться,
        // Так как индекс таких потомков будет превышать размер массива, следовательно и условие запускающее дальнейшую рекурсию не выполниться.
        // Так как функция ничего не возвращает, то после выполнения посленей проверки, она завершиться и закроет все рекурсивно вызванные функции перед собой.
        Heapify(array,size,largest);
    }
};

template <class T>
// Функция превращающая массив в убывающую кучу.
void MakeHeap(T array[], int size){
    // Для создании кучи, нужно применить функцию восстановления свойств кучи для каждого элемента кучи, имеющего потомков.
    // Так как куча двоичная, то потомко будут иметь только элементы начиная с её середины, а поскольку массив начинается с нуля, то необходимо также уменьшить размер на 1.
    for (int i = (size/2) -1; i >= 0; --i) {
        Heapify(array,size,i);
    }
};
template <class T>
// Функция сортировки кучи принимающая массив с построенной кучей и его размер.
void SortHeap(T array[], int size){
    // Принцип сортировки - Так как убывающей куче корневой элемент является наибольшим то можно провести сортировку поменяв его местами
    // с последним элементом массива, а затем вызвав функцию восстановления свойств кучи, с размером массива на единицу меньше.
    // Таким образом необходимо пройти по всему массиву, в процессе сортировки, левая часть массива будет представлять из себя кучу, а правая отсортированный по возрастанию массив.
    // Так как цикл for - линейный а Heapify выполняется логарифмически, то при сортировке идеального бинарного дерева, сортировка будет выполняться за n*log(n).
    for (int i = size-1; i >= 0 ; --i) {
        Swap(array[0],array[i]);
        Heapify(array,i,0);
    }
};

// Вспомогательные функции
template <class T>
void FillArray(T array[], int size){
    for (int i = 0; i < size; ++i) {
        array[i] = i;
    }
}
template <class T>
void ShowArray(T array[], int size){
    for (int i = 0; i < size; ++i) {
        std::cout << "Element № " << i << " = " << array[i] << std::endl;
    }
}



int main(){
    int size = 15;
    int* array = new int[size];
    FillArray(array,size);
    ShowArray(array,size);
    std::cout << "--------Before--------" << std::endl;
    MakeHeap(array,size);
    std::cout << "--------After--------" << std::endl;
    ShowArray(array,size);

    std::cout << "--------Before Sort--------" << std::endl;
    ShowArray(array, size);
    SortHeap(array,size);
    std::cout << "--------After Sort--------" << std::endl;
    ShowArray(array, size);
}